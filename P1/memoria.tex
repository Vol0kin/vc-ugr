\documentclass[11pt,a4paper]{article}
\usepackage[spanish,es-nodecimaldot]{babel}	% Utilizar español
\usepackage[utf8]{inputenc}					% Caracteres UTF-8
\usepackage{graphicx}						% Imagenes
\usepackage[hidelinks]{hyperref}			% Poner enlaces sin marcarlos en rojo
\usepackage{fancyhdr}						% Modificar encabezados y pies de pagina
\usepackage{float}							% Insertar figuras
\usepackage[textwidth=390pt]{geometry}		% Anchura de la pagina
\usepackage[nottoc]{tocbibind}				% Referencias (no incluir num pagina indice en Indice)
\usepackage{enumitem}						% Permitir enumerate con distintos simbolos
\usepackage[T1]{fontenc}					% Usar textsc en sections
\usepackage{amsmath}						% Símbolos matemáticos
\usepackage{subcaption}


\usepackage{listings}
\usepackage{xcolor}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4,
    language=Python
}
 
\lstset{style=mystyle}

% Comando para poner el nombre de la asignatura
\newcommand{\asignatura}{Visión por Computador}
\newcommand{\autor}{Vladislav Nikolov Vasilev}
\newcommand{\titulo}{Trabajo 1}
\newcommand{\subtitulo}{Filtrado y Detección de Regiones}

% Configuracion de encabezados y pies de pagina
\pagestyle{fancy}
\lhead{\autor{}}
\rhead{\asignatura{}}
\lfoot{Grado en Ingeniería Informática}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}		% Linea cabeza de pagina
\renewcommand{\footrulewidth}{0.4pt}		% Linea pie de pagina

\begin{document}
\pagenumbering{gobble}

% Pagina de titulo
\begin{titlepage}

\begin{minipage}{\textwidth}

\centering

\includegraphics[scale=0.5]{img/ugr.png}\\

\textsc{\Large \asignatura{}\\[0.2cm]}
\textsc{GRADO EN INGENIERÍA INFORMÁTICA}\\[1cm]

\noindent\rule[-1ex]{\textwidth}{1pt}\\[1.5ex]
\textsc{{\Huge \titulo\\[0.5ex]}}
\textsc{{\Large \subtitulo\\}}
\noindent\rule[-1ex]{\textwidth}{2pt}\\[3.5ex]

\end{minipage}

\vspace{0.5cm}

\begin{minipage}{\textwidth}

\centering

\textbf{Autor}\\ {\autor{}}\\[2.5ex]
\textbf{Rama}\\ {Computación y Sistemas Inteligentes}\\[2.5ex]
\vspace{0.3cm}

\includegraphics[scale=0.3]{img/etsiit.jpeg}

\vspace{0.7cm}
\textsc{Escuela Técnica Superior de Ingenierías Informática y de Telecomunicación}\\
\vspace{1cm}
\textsc{Curso 2019-2020}
\end{minipage}
\end{titlepage}

\pagenumbering{arabic}
\tableofcontents
\thispagestyle{empty}				% No usar estilo en la pagina de indice

\newpage

\setlength{\parskip}{1em}

\section{\textsc{Ejercicio sobre filtros básicos}}

\noindent \textbf{USANDO LAS FUNCIONES DE OPENCV}: escribir funciones que implementen los siguientes puntos:

\begin{enumerate}[label=\textbf{\Alph*)}]
	\item \textbf{El cálculo de la convolución de una imagen con una máscara 2D. Usar una Gaussiana 2D (GaussianBlur)
	y máscaras 1D dadas por getDerivKernels). Mostrar ejemplos con distintos tamaños de máscara, valores de
	sigma y condiciones de contorno. Valorar los resultados.}
	\item \textbf{Usar la función Laplacian para el cálculo de la convolución 2D con una máscara normalizada de
	Laplaciana-de-Gaussiana de tamaño variable. Mostrar ejemplos de funcionamiento usando dos tipos de
	bordes y dos valores de sigma: 1 y 3.}
\end{enumerate}

\subsection{Apartado A}

Para realizar todas las pruebas, vamos a utilizar una imágen en blanco y negro. De esta forma, los resultados se podrán
ver de forma más clara. Se puede utilizar cualquiera de las imágenes que se han proporcionado, pero vamos a utilizar
la foto del gato. A continuación se puede ver la imágen en cuestión:

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{img/cat.png}
\caption{Imágen original del gato en blanco y negro.}
\label{fig:cat}
\end{figure}

Antes de ver cuáles son los resultados y compararlos. Hace falta aclarar algunos puntos:

\begin{itemize}
	\item Cuando se cargan las imágenes, se convierten a \textit{float64}, para así tener más precisión a la hora de
	hacer las posteriores operaciones (aplicar filtros, sumar o restar imágenes, etc.), además de que así no nos limitamos
	a usar solo valores en el rango $[0, 255]$.
	\item Las operaciones para aplicar filtros de OpenCV aplican una correlación. Por tanto, para aplicar una convolución,
	se debe realizar un \textit{flip} del \textit{kernel}; esto es, darle la vuelta en el eje $X$ y en el eje $Y$.
	Como en todos los casos trabajaremos con \textit{kernels} separables, solo será necesario darles la vuelta en un sentido.
	\item Respecto al punto anterior, al trabajar con \textit{kernels} separables, con tal de mejorar la eficiencia,
	se puede aplicar primero el \textit{kernel} del eje $X$ y, sobre el resultado, aplicar el \textit{kernel} en el
	eje $Y$. Esto es mucho más rápido que aplicar directamente un \textit{kernel} 2D sobre la imágen, debido a que el
	número de operaciones es mucho menor.
\end{itemize}

Como en este ejercicio se piden aplicar \textit{kernels} de Gaussiana y de derivada, se han hecho funciones específicas
las cuáles pueden ser consultadas en el código. Estas funciones son \textit{gaussian\_kernel()} y \textit{derivative\_kernel()},
respectivamente. No se va a especificar exactamente lo que hacen debido a que solo obtienen los \textit{kernels} con los
parámetros adecuados (valores de $\sigma$ y tamaño de cada \textit{kernel} para el caso de la Gaussiana, y tamaño del
\textit{kernel} y número de veces que se deriva en cada eje en el caso de la derivada).

Lo que sí que es importante destacar es que estas dos funciones utilizan una común para realizar la convolución. Como se
dijo anteriormente, OpenCV realiza como tal la correlación, pero se puede aplicar una convolución realizando unos pocos cambios.
La función que se puede ver a continuación recibe un \textit{kernel} para cada eje y aplica el filtro mediante la
convolución:

\begin{lstlisting}[label={alg:apply-kernel}]
def apply_kernel(img, kx, ky, border):
    """
    Funcion que aplica un kernel separable sobre una imagen,
    realizando una convolucion

    Args:
        img: Imagen sobre la que aplicar el filtro
        kx: Kernel en el eje X
        ky: Kernel en el eje Y
        border: Tipo de borde
    Return:
        Devuelve una imagen filtrada
    """
    # Hacer el flip a los kernels para aplicarlos como una convolucion
    kx_flip = np.flip(kx)
    ky_flip = np.flip(ky)

    # Realizar la convolucion
    conv_x = cv.filter2D(img, cv.CV_64F, kx_flip.T,
    					 borderType=border)
    conv = cv.filter2D(conv_x, cv.CV_64F, ky_flip,
    				   borderType=border)

    return conv
\end{lstlisting}

Como se puede ver, se tiene que hacer un \textit{flip} de los \textit{kernels} para poder aplicar una convolución.
Al aplicar cada \textit{kernel} de forma separada mediante $filter2D$, se consigue una mayor eficiencia (como se ha
mencionado anteriormente). Es importante destacar que primero se aplica el \textit{kernel} sobre el eje de las $X$ y,
sobre el resultado obtenido, se aplica el \textit{kernel} en el eje $Y$. También es importante destacar que, cuando
se aplica el \textit{kernel} sobre el eje $X$, se le pasa la traspuesta del \textit{kernel}. Esto se debe a que
OpenCV proporciona los \textit{kernels} como vectores columnas, y para pasarlo por las filas, necesitamos que sea
un vector fila. Al traponer el vector columna obtenemos, como parece lógico, un vector columna.

Otra cosa muy importante a destacar son los \textit{kernels} que se van a utilizar. Uno de ellos es el \textit{kernel}
Gaussiano, el cuál es simétrico tanto en el eje $X$ como en el $Y$. Al aplicarlo, por tanto, se podría ahorrar la
operación del \textit{flip}, ya que lo va a dejar igual. Sin embargo, debido a que se ha implementado la función
para que sea genérica, se realiza esta operación. El otro \textit{kernel} que se utiliza es el de las derivadas,
que no es más que un \textit{kernel} de Sobel, el cuál combina alisamiento Gaussiano con la derivada.
A diferencia del anterior \textit{kernel}, este no es simétrico, y por tanto, la operación de
\textit{flip} no lo va a dejar igual; por tanto, no puede ser ahorrada en este caso.

Con esto comentado, ya podemos empezar a hablar de los resultados que se han obtenido. Para ello, vamos a comenzar
comentando los resultados que se obtienen para el filtro Gaussiano.

Lo primero que se ha probado es un \textit{kernel} de $5 \times 5$, variando los valores de $\sigma$ para ver cómo cambiaba.
A continuación se pueden ver los resultados:

\begin{figure}[H]
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[scale=0.48]{img/gauss-sigma1.png}
	\subcaption{Filtro Gaussiano con $\sigma = 1$.}
	\label{fig:gauss-sigma1}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[scale=0.48]{img/gauss-sigma2.png}
	\subcaption{Filtro Gaussiano con $\sigma = 3$.}
	\label{fig:gauss-sigma2}
\end{subfigure}
\caption{Filtro Gaussiano con diferentes tamaños de $\sigma$.}
\label{fig:gauss-sigma}
\end{figure}

Como se puede ver, comparando cualquiera de las imágenes de la figura \ref{fig:gauss-sigma} con \ref{fig:cat}, existen ciertas
diferencias. Podemos ver claramente como al aplicar el filtro Gaussiano se ha perdido cierto detalle, ya que se están
eliminando las frecuencias altas. Además, si comparamos las figuras \ref{fig:gauss-sigma1} y \ref{fig:gauss-sigma2}, podemos
ver que a medida que aumentamos el tamaño de $\sigma$, se van perdiendo más detalles, ya que se emborrona más.

Se ha probado también a variar el tamaño de la máscara, conservando el mismo valor de $\sigma$, para ver qué es lo que sucede.
A continuación, se puede ver lo que se ha obtenido:

\begin{figure}[H]
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[scale=0.48]{img/gauss-sigma2.png}
	\subcaption{Filtro Gaussiano de tamaño $5 \times 5$.}
	\label{fig:gauss-sigma3}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[scale=0.48]{img/gauss-size.png}
	\subcaption{Filtro Gaussiano de tamaño $11 \times 11$.}
	\label{fig:gauss-size1}
\end{subfigure}
\caption{Filtro Gaussiano con diferentes tamaños de \textit{kernel}.}
\label{fig:gauss-size}
\end{figure}

Tal y como se puede ver en la figura \ref{fig:gauss-size}, al modificar el tamaño del \textit{kernel} se han obtenido
diferentes resultados. Esto se debe a que, si se tiene un valor de $\sigma$ alto con una máscara pequeña, esta tiende
a comportarse como un filtro de caja, ponderando más o menos de forma equitativa a los vecinos del píxel


\subsection{Apartado B}

\newpage

\section{\textsc{Ejercicio sobre pirámides y detección de regiones}}

\noindent \textbf{IMPLEMENTAR} funciones para las siguiente tareas:

\begin{enumerate}[label=\textbf{\Alph*)}]
	\item \textbf{Una función que genere una representación en pirámide Gaussiana de 4 niveles de una
	imagen. Mostrar ejemplos de funcionamiento usando bordes y justificar la elección de los parámetros.}
	\item \textbf{Una función que genere una representación en pirámide Laplaciana de 4 niveles de una imagen.
	Mostrar ejemplos de funcionamiento usando bordes.}
	\item \textbf{Construir un espacio de escalas Laplaciano para implementar la búsqueda de regiones usando el siguiente
	algoritmo:}
	\begin{enumerate}[label=\textbf{\alph*.}]
		\item Fijar sigma
		\item Repetir para N escalas
		\item Realizar supresión de no-máximos en cada escala
		\begin{enumerate}[label=\roman*.]
			\item Filtrar la imagen con la Laplaciana-Gaussiana normalizada en escala
			\item Guardar el cuadrado de la respuesta para el actual nivel del espacio de escalas
			\item Incrementar el valor de sigma por un coeficiente k.( 1.2-1.4)
		\end{enumerate}
		\item Mostrar las regiones encontradas en sus correspondientes escalas. Dibujar círculos con radio proporcional a
		la escala.
	\end{enumerate}
\end{enumerate}

\subsection{Apartado A}

\subsection{Apartado B}

\subsection{Apartado C}

\newpage

\section{\textsc{Imágenes híbridas}}

\noindent \textbf{Mezclando adecuadamente una parte de las frecuencias altas de una imagen con una parte de
las frecuencias bajas de otra imagen, obtenemos una imagen híbrida que admite distintas interpretaciones a distintas
distancias (ver hybrid images project page).}

\noindent \textbf{Para seleccionar la parte de frecuencias altas y bajas que nos quedamos
de cada una de las imágenes usaremos el parámetro sigma del núcleo/máscara de alisamiento gaussiano que usaremos.
A mayor valor de sigma mayor eliminación de altas frecuencias en la imagen convolucionada. Para una buena
implementación elegir dicho valor de forma separada para cada una de las dos imágenes (ver las recomendaciones
dadas en el paper de Oliva et al.). Recordar que las máscaras 1D siempre deben tener de longitud un número impar.}

\noindent \textbf{Implementar una función que genere las imágenes de baja y alta frecuencia a partir de las
parejas de imágenes (solo en la versión de imágenes de gris). El valor de sigma más adecuado para cada pareja
habrá que encontrarlo por experimentación.}

\begin{enumerate}
	\item Escribir una función que muestre las tres imágenes (alta, baja e híbrida) en una misma ventana.
	(Recordar que las imágenes después de una convolución contienen número flotantes que pueden ser positivos y negativos)
	\item Realizar la composición con al menos 3 de las parejas de imágenes
	\item Construir pirámides gaussianas de al menos 4 níveles con las imágenes resultado. Explicar el efecto que se observa.
\end{enumerate}

\subsection{Apartado 1}

\subsection{Apartado 2}

\subsection{Apartado 3}

\newpage

\section{\textsc{Bonus}}

\subsection{Convolución 2D propia}

\noindent \textbf{Implementar con código propio la convolución 2D con cualquier máscara 2D de números reales usando
máscaras separables.}

\subsection{Imágenes híbridas a color}

\noindent \textbf{Realizar todas las parejas de imágenes híbridas en su formato a color (solo se tendrá en cuenta
si la versión de gris es correcta).}

\subsection{Imágen híbrida propia}

\noindent \textbf{Realizar una imagen híbrida con al menos una pareja de imágenes de su elección que hayan
sido extraídas de imágenes más grandes. Justifique la elección y todos los pasos que realiza.}

\newpage

\begin{thebibliography}{5}

\bibitem{nombre-referencia}
Texto referencia
\\\url{https://url.referencia.com}

\end{thebibliography}

\end{document}

